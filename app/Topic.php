<?php

namespace App;

use DB;
use Auth;
use Carbon\Carbon;
use Illuminate\Database\Eloquent\Model;

class Topic extends Model
{
    /**
     * Define fillable field in the model
     *
     * @var array
     */
    protected $fillable = [
        'name',
        'description',
        'avatar_img_id'
    ];


    /**
     * Override create method for creating necessary associate model
     *
     * @param array $attributes
     * @return static
     */
    public static function create(array $attributes = []) {
        $topic = parent::create($attributes); // TODO: Change the autogenerated stub
        // bookmark hit
        Hit::create([
            'owner_type' => 'App\Topic',
            'owner_id' => $topic->id
        ]);
        return $topic;
    }

    /**
     * A topic will have many question
     *
     * @return \Illuminate\Database\Eloquent\Relations\BelongsToMany
     */
    public function questions() {
        return $this->belongsToMany('App\Question')->withTimestamps();
    }

    /**
     * A topic page has a hit
     */
    public function getHitAttribute() {
        return Hit::whereOwnerType('App\Topic')->whereOwnerId($this->id)->first();
    }

    /**
     * A answer may have histories
     *
     * @return \Illuminate\Database\Eloquent\Relations\MorphMany
     */
    public function histories() {
        return $this->morphMany('App\History', 'for_item');
    }


    /**
     * Override update function so that it could record name/description content history
     *
     * @param array $attributes
     * @param array $options
     * @return bool|int
     */
    public function update(array $attributes = [], array $options = [])
    {
        $user = Auth::user();
        // set title history
        if (isset($attributes['name']) && $attributes['name'] != $this->name) {
            $history = History::create([
                'user_id' => $user->id,
                'type' => 1,
                'text' => $this->name
            ]);
            $this->histories()->save($history);
        }

        // set description history
        if (isset($attributes['description']) && $attributes['description'] != $this->description) {
            $history = History::create([
                'user_id' => $user->id,
                'type' => 2,
                'text' => $this->description
            ]);
            $this->histories()->save($history);
        }

        return parent::update($attributes, $options); // TODO: Change the autogenerated stub
    }


    /**
     * record parent topic change
     *
     * @param $new_topic_list
     */
    public function recordParentTopicsHistory($new_topic_list, $old_topic_list = null) {
        $user = Auth::user();

        // not old_topic_list parameters
        if (!is_array($old_topic_list)) {
            $old_topic_list = $this->parent_topics()->lists('parent_topic_id')->all();
        }

        $new = array_diff($new_topic_list, $old_topic_list);
        $delete = array_diff($old_topic_list, $new_topic_list);
        // set remove topics history
        foreach ($delete as $topic_id) {
            $this->histories()->save(History::create([
                'user_id' => $user->id,
                'type' => 4,
                'text' => $topic_id
            ]));
        }
        // set new topics history
        foreach ($new as $topic_id) {
            $this->histories()->save(History::create([
                'user_id' => $user->id,
                'type' => 3,
                'text' => $topic_id
            ]));
        }
    }


    /**
     * record subtopics topic change
     *
     * @param $new_topic_list
     */
    public function recordSubtopicsHistory($new_topic_list, $old_topic_list = null) {
        $user = Auth::user();

        // not old_topic_list parameters
        if (!is_array($old_topic_list)) {
            $old_topic_list = $this->subtopics()->lists('subtopic_id')->all();
        }

        // get difference
        $new = array_diff($new_topic_list, $old_topic_list);
        $delete = array_diff($old_topic_list, $new_topic_list);
        // set remove topics history
        foreach ($delete as $topic_id) {
            $this->histories()->save(History::create([
                'user_id' => $user->id,
                'type' => 6,
                'text' => $topic_id
            ]));
        }
        // set new topics history
        foreach ($new as $topic_id) {
            $this->histories()->save(History::create([
                'user_id' => $user->id,
                'type' => 5,
                'text' => $topic_id
            ]));
        }
    }

    /**
     * Get recommend questions
     *
     * @return mixed
     */
    public function getRecommendQuestionsAttribute() {
        $questions = $this->questions->sortByDesc(function($question) {
            $timeDiff = Carbon::parse($question->created_at)->diffInDays(Carbon::now());
            $timeDiff = (30 - $timeDiff) > 0 ? 30 - $timeDiff : 0;
            $numSubscriber = $question->subscribers()->count();
            $numHit = $question->hit->month;
            return $numHit * 7 + $numSubscriber * 5 + $timeDiff;
        });

        return $questions;
    }

    /**
     * Get all questions without answers
     *
     * @return mixed
     */
    public function getWaitAnswerQuestionsAttribute() {
        $questions = $this->questions->filter(function($question) {
            return $question->answers()->count() == 0;
        });
        $questions = $questions->sortBy(function($question) {
            $numHit = $question->hit->month;
            $timeDiff = Carbon::parse($question->created_at)->diffInDays(Carbon::now());
            $timeDiff = (30 - $timeDiff) > 0 ? 30 - $timeDiff : 0;
            $numSubscriber = $question->subscribers()->count();
            return $numHit * 5 + $timeDiff * 2 + $numSubscriber * 4;
        });
        return $questions;
    }

    public function getHighlightQuestionsAttribute() {
        $questions = $this->questions->sortByDesc(function($question) {
            $timeDiff = Carbon::parse($question->created_at)->diffInDays(Carbon::now());
            $timeDiff = (30 - $timeDiff) > 0 ? 30 - $timeDiff : 0;
            $numSubscriber = $question->subscribers()->count();
            $numHit = $question->hit->month;
            return $numHit * 7 + $numSubscriber * 5 + $timeDiff * 3;
        });
        return $questions;
    }

    /**
     * Get hot topics
     */
    public static function getHotTopics() {
        $topics =  Topic::all()->sortByDesc(function($topic) {
            $numSubscriber = $topic->subscribers()->count();
            $numHit = $topic->hit->total;
            return $numSubscriber * 2 + $numHit * 3;
        });
        return Auth::user()->filterTopics($topics);
    }


    /**
     * define query scope. similar match $name
     *
     * @param $query
     * @param $name
     * @return mixed
     */
    public function scopeSimilarMatch($query, $name) {
        return $query->where('name', 'REGEXP', '[' . $name . ']');
    }

    /**
     * Defined eloquent relationship : A topic can be the specialization of many students
     *
     * @return \Illuminate\Database\Eloquent\Relations\HasMany
     */
    public function specialists() {
        return $this->belongsToMany('App\User', 'user_specialization', 'topic_id', 'user_id')->withTimestamps();
    }
    

    /**
     * A topic has it parent topics
     *
     * @return \Illuminate\Database\Eloquent\Relations\BelongsTo
     */
    public function parent_topics() {
        return $this->belongsToMany('App\Topic', 'topic_subtopic', 'subtopic_id', 'parent_topic_id')->withTimestamps();
    }

    /**
     * A topic has many child topics
     *
     * @return \Illuminate\Database\Eloquent\Relations\HasMany
     */
    public function subtopics() {
        return $this->belongsToMany('App\Topic', 'topic_subtopic', 'parent_topic_id', 'subtopic_id')->withTimestamps();
    }

    /**
     * A topic is subscribed by many users' subscribe
     *
     * @return \Illuminate\Database\Eloquent\Relations\BelongsToMany
     */
    public function subscribers() {
        return $this->belongsToMany('App\Subscribe')->withTimestamps();
    }

    /**
     * A topic is hidden to many users.
     *
     * @return \Illuminate\Database\Eloquent\Relations\BelongsToMany
     */
    public function be_hidden() {
        return $this->belongsToMany('App\Topic', 'hide_topic', 'topic_id', 'user_id')->withTimestamps();
    }

    /**
     * define query scope. like match $name
     *
     * @param $query
     * @param $name
     * @return mixed
     */
    public function scopeNoneSimilarMatch($query, $name) {
        return $query->where('name', 'LIKE', '%' . $name . '%');
    }

    /**
     * Return json format
     *
     * @return array
     */
    public function getJsonAttribute() {
        return [
            'name' => $this->name,
            'description' => $this->description,
            'id' => $this->id,
        ];
    }

    /**
     * get top parent(topic without parent topic, root topic)
     *
     * @param $query
     * @return mixed
     */
    public function scopeTopParentTopics($query) {
        return $query->whereNotExists(function ($query) {
            $query->select(DB::raw(1))
                ->from('topic_subtopic')
                ->whereRaw('topic_subtopic.subtopic_id = topics.id');
        });
    }

    /**
     * Determine if a given topic is current topic's parent topic
     *
     * @param $topic
     * @return bool
     */
    public function isSubtopicOf($topic) {
        if ($this->id == $topic->id) {
            return true;
        } else if ($this->parent_topics()->count() == 0) {
            return false;
        } else {
            $results = false;
            foreach ($this->parent_topics as $parent_topic) {
                $results = $results || $parent_topic->isSubtopicOf($topic);
                if ($results) {
                    break;
                }
            }
            return $results;
        }
    }

}
