<?php

namespace App;

use DB;
use Auth;
use Cache;
use Carbon\Carbon;
use Illuminate\Database\Eloquent\Model;

class Topic extends Model
{
    /**
     * Define fillable field in the model
     *
     * @var array
     */
    protected $fillable = [
        'name',
        'description',
        'avatar_img_id'
    ];


    /**
     * Override create method for creating necessary associate model
     *
     * @param array $attributes
     * @return static
     */
    public static function create(array $attributes = []) {
        $topic = parent::create($attributes); // TODO: Change the autogenerated stub
        // bookmark hit
        Hit::create([
            'owner_type' => 'App\Topic',
            'owner_id' => $topic->id
        ]);

        // create by who?
        $user = Auth::user();

        // title
        $history = History::create([
            'user_id' => $user->id,
            'type' => 1,
            'text' => $topic->name
        ]);
        $topic->histories()->save($history);

        // description
        $history = History::create([
            'user_id' => $user->id,
            'type' => 2,
            'text' => $topic->description
        ]);
        $topic->histories()->save($history);

        return $topic;
    }

    /**
     * A topic will have many question
     *
     * @return \Illuminate\Database\Eloquent\Relations\BelongsToMany
     */
    public function questions() {
        return $this->belongsToMany('App\Question')->withTimestamps();
    }

    public function getPublishedQuestionsAttribute() {
        return $this->questions()->published()->get();
    }

    /**
     * A topic page has a hit
     */
    public function getHitAttribute() {
        return Hit::whereOwnerType('App\Topic')->whereOwnerId($this->id)->first();
    }

    /**
     * A answer may have histories
     *
     * @return \Illuminate\Database\Eloquent\Relations\MorphMany
     */
    public function histories() {
        return $this->morphMany('App\History', 'for_item');
    }


    /**
     * Override update function so that it could record name/description content history
     *
     * @param array $attributes
     * @param array $options
     * @return bool|int
     */
    public function update(array $attributes = [], array $options = [])
    {
        $user = Auth::user();
        // set title history
        if (isset($attributes['name']) && $attributes['name'] != $this->name) {
            $history = History::create([
                'user_id' => $user->id,
                'type' => 1,
                'text' => $this->name
            ]);
            $this->histories()->save($history);
        }

        // set description history
        if (isset($attributes['description']) && $attributes['description'] != $this->description) {
            $history = History::create([
                'user_id' => $user->id,
                'type' => 2,
                'text' => $this->description
            ]);
            $this->histories()->save($history);
        }

        return parent::update($attributes, $options); // TODO: Change the autogenerated stub
    }


    /**
     * Close an topic
     *
     * @return bool
     */
    public function close() {
        $user = Auth::user();
        // check authority
        if (!$user->operation(16)) {
            return false;
        }

        // change question status
        $this->status = 2;
        $this->save();

        return true;
    }

    /**
     * Reopen the question with reason
     *
     * @return bool
     */
    public function open() {
        $user = Auth::user();
        // check authority
        if (!$user->operation(16)) {
            return false;
        }

        // change question status
        $this->status = 1;
        $this->save();

        return true;
    }

    /**
     * Determine if the topic is closed
     *
     * @return bool
     */
    public function isClosed() {
        return $this->status == 2;
    }

    /**
     * Return the latest close reason for the question
     */
    public function closeReason() {
        if ($this->histories()->whereType(10)->exists()) {
            return $this->histories()
                ->whereType(10)->orderBy('created_at', 'desc')
                ->first()->text;
        } else {
            return false;
        }
    }


    /**
     * record parent topic change
     *
     * @param $new_topic_list
     */
    public function recordParentTopicsHistory($new_topic_list, $old_topic_list = null) {
        $user = Auth::user();

        // not old_topic_list parameters
        if (!is_array($old_topic_list)) {
            $old_topic_list = $this->parent_topics()->lists('parent_topic_id')->all();
        }

        $new = array_diff($new_topic_list, $old_topic_list);
        $delete = array_diff($old_topic_list, $new_topic_list);
        // set remove topics history
        foreach ($delete as $topic_id) {
            $this->histories()->save(History::create([
                'user_id' => $user->id,
                'type' => 4,
                'text' => $topic_id
            ]));
        }
        // set new topics history
        foreach ($new as $topic_id) {
            $this->histories()->save(History::create([
                'user_id' => $user->id,
                'type' => 3,
                'text' => $topic_id
            ]));
        }
    }


    /**
     * record subtopics topic change
     *
     * @param $new_topic_list
     */
    public function recordSubtopicsHistory($new_topic_list, $old_topic_list = null) {
        $user = Auth::user();

        // not old_topic_list parameters
        if (!is_array($old_topic_list)) {
            $old_topic_list = $this->subtopics()->lists('subtopic_id')->all();
        }

        // get difference
        $new = array_diff($new_topic_list, $old_topic_list);
        $delete = array_diff($old_topic_list, $new_topic_list);
        // set remove topics history
        foreach ($delete as $topic_id) {
            $this->histories()->save(History::create([
                'user_id' => $user->id,
                'type' => 6,
                'text' => $topic_id
            ]));
        }
        // set new topics history
        foreach ($new as $topic_id) {
            $this->histories()->save(History::create([
                'user_id' => $user->id,
                'type' => 5,
                'text' => $topic_id
            ]));
        }
    }

    /**
     * Get recommend questions
     *
     * @return mixed
     */
    public function recommendQuestions($page, $itemInPage, $sorted = "default") {
        $all_questions = Cache::remember(
            'topic_' . $this->id . '_questions', 10, function() {
            return $this->questions()->published()->get();
        });

        if ($sorted == 'created') {
            $recommend = Cache::remember(
                'topic_' . $this->id . '_recommend_questions_' . $page . '_'. $itemInPage . '_' . $sorted,
                10,
                function() use ($all_questions, $page, $itemInPage){
                    return $all_questions->sortByDesc('created_at')->forPage($page, $itemInPage);
                });
        } else {
            $recommend = Cache::remember(
                'topic_' . $this->id . '_recommend_questions_' . $page . '_'. $itemInPage . '_' . $sorted,
                10,
                function() use ($all_questions, $page, $itemInPage){
                    return $all_questions->sortByDesc(function ($question) {
                        $timeDiff = Carbon::parse($question->created_at)->diffInDays(Carbon::now());
                        $timeDiff = (30 - $timeDiff) > 0 ? 30 - $timeDiff : 0;
                        $numSubscriber = $question->subscribers()->count();
                        $numHit = $question->hit->month;
                        return $numHit * 7 + $numSubscriber * 5 + $timeDiff;
                    })->forPage($page, $itemInPage);
                });
        }

        return $recommend;
    }

    /**
     * Get all questions without answers
     *
     * @return mixed
     */
    public function waitAnswerQuestions($page, $itemInPage, $sorted = "default") {
        // get all topic questions
        $all_questions = Cache::remember(
            'topic_' . $this->id . '_questions', 10, function() {
            return $this->questions()->published()->get();
        });

        if ($sorted == 'created') {
            // cache with pagination
            // cache with pagination
            $wait = Cache::remember(
                'topic_' . $this->id . '_wait_questions_' . $page . '_'. $itemInPage . '_' . $sorted,
                10,
                function() use ($all_questions, $page, $itemInPage) {
                    $questions = $all_questions->filter(function($question) {
                        return $question->answers()->count() == 0;
                    });
                    return $questions->sortByDesc('created_at')->forPage($page, $itemInPage);
                });
        } else {
            $wait = Cache::remember(
                'topic_' . $this->id . '_wait_questions_' . $page . '_'. $itemInPage . '_' . $sorted,
                10,
                function() use ($all_questions, $page, $itemInPage) {
                    $questions = $all_questions->filter(function($question) {
                        return $question->answers()->count() == 0;
                    });
                    $questions = $questions->sortBy(function($question) {
                        $numHit = $question->hit->month;
                        $timeDiff = Carbon::parse($question->created_at)->diffInDays(Carbon::now());
                        $timeDiff = (30 - $timeDiff) > 0 ? 30 - $timeDiff : 0;
                        $numSubscriber = $question->subscribers()->count();
                        return $numHit * 5 + $timeDiff * 2 + $numSubscriber * 4;
                    });
                    return $questions->forPage($page, $itemInPage);
                });
        }


        return $wait;
    }

    /**
     * Get highlight questions
     *
     * @param $page
     * @param $itemInPage
     * @return mixed
     */
    public function highlightQuestions($page, $itemInPage, $sorted = "default") {

        // get all topic questions
        $all_questions = Cache::remember(
            'topic_' . $this->id . '_questions', 10, function() {
            return $this->questions()->published()->get();
        });

        // cache with pagination
        if ($sorted == 'created') {
            $highlight = Cache::remember(
                'topic_' . $this->id . '_highlight_questions_' . $page . '_'. $itemInPage . '_' . $sorted,
                10,
                function() use ($all_questions, $page, $itemInPage) {
                    return $all_questions->sortByDesc('created_at')->forPage($page, $itemInPage);
                });
        } else {
            $highlight = Cache::remember(
                'topic_' . $this->id . '_highlight_questions_' . $page . '_'. $itemInPage . '_' . $sorted,
                10,
                function() use ($all_questions, $page, $itemInPage) {
                    $questions = $all_questions->sortBy(function($question) {
                        $timeDiff = Carbon::parse($question->created_at)->diffInDays(Carbon::now());
                        $timeDiff = (30 - $timeDiff) > 0 ? 30 - $timeDiff : 0;
                        $numSubscriber = $question->subscribers()->count();
                        $numHit = $question->hit->month;
                        return $numHit * 7 + $numSubscriber * 5 + $timeDiff * 3;
                    });
                    return $questions->forPage($page, $itemInPage);
                });
        }


        return $highlight;
    }

    /**
     * Get hot topics
     */
    public static function getHotTopics() {
        $hotTopics = Cache::remember('hot_topics', 10, function() {
            return Topic::opened()->get()->sortByDesc(function($topic) {
                $numSubscriber = $topic->subscribers()->count();
                $numHit = $topic->hit->total;
                return $numSubscriber * 2 + $numHit * 3;
            });
        });

        if (Auth::user()) {
            return Auth::user()->filterTopics($hotTopics);
        } else {
            return $hotTopics;
        }
    }


    /**
     * define query scope. similar match $name
     *
     * @param $query
     * @param $name
     * @return mixed
     */
    public function scopeSimilarMatch($query, $name) {
        return $query->opened()->where('name', 'REGEXP', '[' . $name . ']');
    }

    /**
     * Defined eloquent relationship : A topic can be the specialization of many students
     *
     * @return \Illuminate\Database\Eloquent\Relations\HasMany
     */
    public function specialists() {
        return $this->belongsToMany('App\User', 'user_specialization', 'topic_id', 'user_id')->withTimestamps();
    }
    

    /**
     * A topic has it parent topics
     *
     * @return \Illuminate\Database\Eloquent\Relations\BelongsTo
     */
    public function parent_topics() {
        return $this->belongsToMany('App\Topic', 'topic_subtopic', 'subtopic_id', 'parent_topic_id')->withTimestamps();
    }

    /**
     * A topic has many child topics
     *
     * @return \Illuminate\Database\Eloquent\Relations\HasMany
     */
    public function subtopics() {
        return $this->belongsToMany('App\Topic', 'topic_subtopic', 'parent_topic_id', 'subtopic_id')->withTimestamps();
    }

    /**
     * A topic is subscribed by many users' subscribe
     *
     * @return \Illuminate\Database\Eloquent\Relations\BelongsToMany
     */
    public function subscribers() {
        return $this->belongsToMany('App\Subscribe')->withTimestamps();
    }

    /**
     * A topic is hidden to many users.
     *
     * @return \Illuminate\Database\Eloquent\Relations\BelongsToMany
     */
    public function be_hidden() {
        return $this->belongsToMany('App\Topic', 'hide_topic', 'topic_id', 'user_id')->withTimestamps();
    }

    /**
     * define query scope. like match $name
     *
     * @param $query
     * @param $name
     * @return mixed
     */
    public function scopeNoneSimilarMatch($query, $name) {
        return $query->opened()->where('name', 'LIKE', '%' . $name . '%');
    }

    /**
     * Return json format
     *
     * @return array
     */
    public function getJsonAttribute() {
        return [
            'name' => $this->name,
            'description' => $this->description,
            'id' => $this->id,
        ];
    }

    /**
     * get top parent(topic without parent topic, root topic)
     *
     * @param $query
     * @return mixed
     */
    public function scopeTopParentTopics($query) {
        return $query->opened()->whereNotExists(function ($query) {
            $query->select(DB::raw(1))
                ->from('topic_subtopic')
                ->whereRaw('topic_subtopic.subtopic_id = topics.id');
        });
    }

    /**
     * Query open topics
     *
     * @param $query
     * @return mixed
     */
    public function scopeOpened($query) {
        return $query->whereStatus(1);
    }

    /**
     * Determine if a given topic is current topic's parent topic
     *
     * @param $topic
     * @return bool
     */
    public function isSubtopicOf($topic) {
        if ($this->id == $topic->id) {
            return true;
        } else if ($this->parent_topics()->count() == 0) {
            return false;
        } else {
            $results = false;
            foreach ($this->parent_topics as $parent_topic) {
                $results = $results || $parent_topic->isSubtopicOf($topic);
                if ($results) {
                    break;
                }
            }
            return $results;
        }
    }

    /**
     * To json format
     */
    public function toJsonFormat() {
        $topic_basic = [
            'id' => $this->id,
            'name' => $this->name,
            'description' => $this->description,
            'numSubtopic' => $this->subtopics()->count(),
            'pic' => DImage($this->avatar_img_id, 40, 40),
        ];

        if (Auth::user()) {
            $topic_basic['isSubscribed'] = Auth::user()->subscribe->checkHasSubscribed($this->id, 'topic');
        } else {
            $topic_basic['guest'] = true;
        }

        return $topic_basic;
    }

}
