<?php

namespace App;

use Carbon\Carbon;
use Cache;
use DB;
use Auth;
use Htmldom;
use Illuminate\Database\Eloquent\Model;

class Question extends Model
{
    /**
     * Define fillable field in the model
     *
     * @var array
     */
    protected $fillable = [
        'title',
        'content',
        'status',
        'reward'
    ];


    /**
     * Override create method for creating necessary associate model
     *
     * @param array $attributes
     * @return static
     */
    public static function create(array $attributes = []) {
        $question = parent::create($attributes); // TODO: Change the autogenerated stub
        // bookmark hit
        Hit::create([
            'owner_type' => 'App\Question',
            'owner_id' => $question->id
        ]);
        return $question;
    }


    /**
     * Override update function so that it could record title content history
     *
     * @param array $attributes
     * @param array $options
     * @return bool|int
     */
    public function update(array $attributes = [], array $options = [])
    {
        $user = Auth::user();

        if (isset($options['history']) && $options['history']) {
            // set title history
            if (isset($attributes['title']) && $attributes['title'] != $this->title) {
                $history = History::create([
                    'user_id' => $user->id,
                    'type' => 1,
                    'text' => $this->title
                ]);
                $this->histories()->save($history);
            }

            // set description history
            if (isset($attributes['content']) && $attributes['content'] != $this->content) {
                $history = History::create([
                    'user_id' => $user->id,
                    'type' => 2,
                    'text' => $this->content
                ]);
                $this->histories()->save($history);
            }

            // set reward history
            if (isset($attributes['reward']) && $attributes['reward'] != $this->reward) {
                $history = History::create([
                    'user_id' => $user->id,
                    'type' => 7,
                    'text' => $this->reward
                ]);
                $this->histories()->save($history);
            }
        }


        return parent::update($attributes, $options); // TODO: Change the autogenerated stub
    }


    /**
     * Save draft to question
     *
     * @param array $attributes
     * @param array $options
     * @return bool
     */
    public function saveDraft(array $attributes = [], array $options = []) {
        $user = Auth::user();
        // already saved answer
        if ($this->owner->id != $user->id || $this->status != 2) {
            // this answer is not created by the user
            // the answer is in published status / close status
            return false;
        }
        // update answer
        $this->update($attributes, $options);
        return true;
    }

    /**
     * Set question as publish status
     *
     * @return bool
     */
    public function publish() {
        $user = Auth::user();
        // set an answer as publish status
        // check if answer belongs to the current user
        if ($user->id != $this->owner->id || $this->status != 2) {
            // only draft status answer can be pulished
            return false;
        }

        // change question status
        $this->status = 1;
        // update time
        $this->created_at = Carbon::now();
        $this->save();

        return true;
    }

    /**
     * Close an question
     *
     * @return bool
     */
    public function close() {
        $user = Auth::user();
        // check authority
        if (!$user->operation(14) && $user->id != $this->owner->id) {
            return false;
        }

        // change question status
        $this->status = 3;
        $this->save();

        return true;
    }

    /**
     * Reopen the question with reason
     *
     * @return bool
     */
    public function open() {
        $user = Auth::user();
        // check authority
        if (!$user->operation(14)) {
            return false;
        }

        // change question status
        $this->status = 1;
        $this->save();

        return true;
    }


    /**
     * Determine if the question is closed
     *
     * @return bool
     */
    public function isClosed() {
        return $this->status == 3;
    }

    /**
     * Return the latest close reason for the question
     */
    public function closeReason() {
        if ($this->histories()->whereType(5)->exists()) {
            return $this->histories()
                ->whereType(5)->orderBy('created_at', 'desc')
                ->first()->text;
        } else {
            return false;
        }
    }

    /**
     * Get closed answers of the question
     *
     * @return bool
     */
    public function closedAnswers() {
        if ($this->answers()->whereStatus(3)->exists()) {
            return $this->answers()->whereStatus(3)->get();
        } else {
            return collect();
        }
    }

    /**
     * record topic change
     *
     * @param $new_topic_list
     */
    public function recordTopicsHistory($new_topic_list, $old_topic_list = null) {
        $user = Auth::user();
        // get difference
        if ($old_topic_list == null) {
            $old_topic_list = $this->topics()->lists('topic_id')->all();
        }

        $new = array_diff($new_topic_list, $old_topic_list);
        $delete = array_diff($old_topic_list, $new_topic_list);
        // set remove topics history
        foreach ($delete as $topic_id) {
            $this->histories()->save(History::create([
                'user_id' => $user->id,
                'type' => 4,
                'text' => $topic_id
            ]));
        }
        // set new topics history
        foreach ($new as $topic_id) {
            $this->histories()->save(History::create([
                'user_id' => $user->id,
                'type' => 3,
                'text' => $topic_id
            ]));
        }
    }


    /**
     * Determine if the question has answer by user
     *
     * @param $user_id
     */
    public function hasPublishedAnswerBy($user_id) {
        return $this->answers()->whereUserId($user_id)->whereStatus(1)->exists();
    }

    /**
     * Get an answer draft by user
     *
     * @param $user_id
     * @return bool
     */
    public function answerDraftBy($user_id) {
        if ($this->answers()->whereUserId($user_id)->whereStatus(2)->exists()) {
            return $this->answers()->whereUserId($user_id)->whereStatus(2)->first();
        } else {
            return false;
        }
    }

    /**
     * send Notification subscriber that question has answer
     *
     * @param $answer
     */
    public function notifySubscriber($answer) {
        // notify all the question subscribe user
        $user = Auth::user();
        foreach ($this->subscribers as $subscriber) {
            $owner = $subscriber->owner;
            // cannot be self-notified
            if ($owner->id == $user->id) continue;
            // check user settings
            if (!$subscriber->owner->canReceiveQuestionUpdateBy($user)) continue;
            // type 2 notification, user answer question
            Notification::notification($owner, 2, $user->id, $answer->id);
        }
    }

    /**
     * A question belongs to a user (is posted by a user)
     *
     * @return \Illuminate\Database\Eloquent\Relations\BelongsTo
     */
    public function owner() {
        return $this->belongsTo('App\User', 'user_id');
    }

    /**
     * A question has many answers.
     *
     * @return \Illuminate\Database\Eloquent\Relations\HasMany
     */
    public function answers() {
        return $this->hasMany('App\Answer');
    }

    /**
     * A question may have replies
     *
     * @return \Illuminate\Database\Eloquent\Relations\MorphMany
     */
    public function replies() {
        return $this->morphMany('App\Reply', 'for_item');
    }

    /**
     * A question belongs to many topics
     *
     * @return \Illuminate\Database\Eloquent\Relations\BelongsToMany
     */
    public function topics() {
        return $this->belongsToMany('App\Topic')->withTimestamps();
    }

    /**
     * A question is subscribed by many users' subscribe
     *
     * @return \Illuminate\Database\Eloquent\Relations\BelongsToMany
     */
    public function subscribers() {
        return $this->belongsToMany('App\Subscribe', 'subscribe_question')->withTimestamps();
    }

    /**
     * A question may belongs to many bookmarks
     *
     * @return \Illuminate\Database\Eloquent\Relations\BelongsToMany
     */
    public function bookmarks() {
        return $this->belongsToMany('App\Bookmark')->withTimestamps();
    }

    /**
     * A answer may have histories
     *
     * @return \Illuminate\Database\Eloquent\Relations\MorphMany
     */
    public function histories() {
        return $this->morphMany('App\History', 'for_item');
    }

    /**
     * Get the excerpt of the question detail
     *
     * @return string
     */
    public function getExcerptAttribute() {
        return truncateText($this->content, 200);
    }

    /**
     * Get also interest questions
     */
    public function getAlsoInterestQuestionsAttribute() {
        $also = Cache::remember('also_interest_question' . $this->id, 10, function() {
            $also_interest = collect();
            foreach ($this->topics()->opened()->orderBy(DB::raw('RAND()'))->get() as $topic) {
                $also_interest = $also_interest->merge($topic->waitAnswerQuestions(1, 10)->take(3));
                $also_interest = $also_interest->merge($topic->highlightQuestions(1, 10)->take(3));
            }
            return $also_interest;
        });
        return $also;
    }

    /**
     * Get news question
     *
     * @return mixed
     */
    public static function news($page, $itemInPage) {
        // cache function to remember for 10 minutes
        $questions = Cache::remember('question_news', 10, function() {
            $questions = Question::published()->get();
            // order by some magic algorithm
            $questions = $questions->sortByDesc(function($question) {
                $timeDiff = Carbon::parse($question->created_at)->diffInDays(Carbon::now());
                $timeDiff = (30 - $timeDiff) > 0 ? 30 - $timeDiff : 0;
                $numSubscriber = $question->subscribers()->count();
                $numHit = $question->hit->day;
                $numVote = $question->highestVote;
                $reward = $question->reward;
                return $numHit * 3 + $numVote
                + $numSubscriber + $timeDiff * 5 + $reward * 5;
            });
            return $questions;
        });
        // pagination with cache
        $news = Cache::remember('question_news_' . $page . '_' . $itemInPage,
            10, function() use ($page, $itemInPage, $questions) {
            return $questions->forPage($page, $itemInPage);
        });

        return $news;
    }

    /**
     * Get recommend questions
     *
     * @return static
     */
    public static function recommendQuestions($page, $itemInPage) {
        $questions = Cache::remember('recommend_questions_' . $page . '_' . $itemInPage , 10 ,
            function() use ($page, $itemInPage) {
            return Question::published()->get()->sortByDesc(
                function($question) use ($page, $itemInPage) {
                $numVote = $question->highestVote;
                $numSubscriber = $question->subscribers()->count();
                $numHit = $question->hit->month;
                $reward = $question->reward;
                return $numVote * 2 + $numSubscriber * 3 + $numHit * 2
                + $reward;
            })->forPage($page, $itemInPage);
        });

        return $questions;
    }


    /**
     * get week hot questions
     *
     * @return static
     */
    public static function weekQuestions($page, $itemInPage) {
        $question = Cache::remember('week_questions_' . $page . '_' . $itemInPage, 10,
            function() use ($page, $itemInPage) {
            return Question::published()->get()->sortByDesc(
                function($question) use ($page, $itemInPage) {
                $timeDiff = Carbon::parse($question->created_at)->diffInDays(Carbon::now());
                $timeDiff = (30 - $timeDiff) > 0 ? 30 - $timeDiff : 0;
                $numVote = $question->highestVote;
                $numSubscriber = $question->subscribers()->count();
                $numHit_week = $question->hit->week;
                $reward = $question->reward;
                return $numVote + $numSubscriber * 2 +
                $numHit_week * 5 + $timeDiff * 2 + $reward;
            })->forPage($page, $itemInPage);
        });
        return $question;
    }

    /**
     * Get current month hot questions
     *
     * @return static
     */
    public static function monthQuestions($page, $itemInPage) {
        $question = Cache::remember('month' . $page . '_' . $itemInPage, 10,
            function() use ($page, $itemInPage) {
            return Question::published()->get()->sortByDesc(
                function($question) use ($page, $itemInPage) {
                $timeDiff = Carbon::parse($question->created_at)->diffInDays(Carbon::now());
                $timeDiff = (30 - $timeDiff) > 0 ? 30 - $timeDiff : 0;
                $numVote = $question->highestVote;
                $numSubscriber = $question->subscribers()->count();
                $numHit_month = $question->hit->month;
                $reward = $question->reward;
                return $numVote + $numSubscriber * 2 +
                $numHit_month * 5 + $timeDiff * 2 + $reward;
            })->forPage($page, $itemInPage);
        });

        return $question;
    }

    /**
     * Get one hot answer from the questions
     */
    public function getHotAnswerAttribute() {
        if ($this->answers()->count() > 0) {
            // use the answer with the highest vote
            $answer = $this->publishedAnswers->sortByDesc(function($answer) {
                $timeDiff = Carbon::parse($answer->created_at)->diffInDays(Carbon::now());
                $timeDiff = (30 - $timeDiff) > 0 ? 30 - $timeDiff : 0;
                $numVote = $answer->netVotes;
                $numHit_month = $answer->hit->month;
                return $numVote + $numHit_month * 2 + $timeDiff * 2;
            })->first();
            return $answer;
        }
        return null;
    }

    /**
     * Display human readable created at date
     *
     * @return string
     */
    public function getCreatedAtHumanReadableAttribute() {
        $created_at = Carbon::parse($this->created_at);
        // if the created at date is more than 3 month ago, display the date
        if (Carbon::now()->subMonth(3)->gte($created_at)) {
            return $created_at->format('Y-m-d');
        } else {
            // or display the humanReadble text (e.g 2 days ago)
            return $created_at->diffForHumans();
        }

    }

    /**
     * Get the highest number of votes in answers of the current question
     *
     * @return int
     */
    public function getHighestVoteAttribute() {
        if($this->answers->count() > 0) {
            return $this->publishedAnswers->max('netVotes');
        } else {
            return 0;
        }
    }

    /**
     * Get published answer
     *
     * @return mixed
     */
    public function getPublishedAnswersAttribute() {
        return $this->answers()->whereStatus(1)->get();
    }

    /**
     * A question has a hit
     */
    public function getHitAttribute() {
        return Hit::whereOwnerType('App\Question')->whereOwnerId($this->id)->first();
    }

    /**
     * define query scope. similar match $name
     *
     * @param $query
     * @param $title
     * @return mixed
     */
    public function scopeSimilarMatch($query, $title) {
        return $query->where('title', 'REGEXP', '[' . $title . ']')
            ->whereStatus(1); // published
    }

    /**
     * define query scope. `like` match $name
     *
     * @param $query
     * @param $title
     * @return mixed
     */
    public function scopeNoneSimilarMatch($query, $title) {
        return $query->where('title', 'LIKE', '%' . $title . '%')
            ->whereStatus(1); // published
    }


    /**
     * search for both title and content
     *
     * @param $query
     * @param $key
     * @param $range (optional)
     * @return mixed
     */
    public function scopeNoneSimilarMatchAll($query, $key, $range = null) {
        if ($range != null) {
            return $query->where(function($query) use ($key) {
                return $query->orWhere('title', 'LIKE' , '%' . $key . '%')
                    ->orWhere('content', 'LIKE' , '%' . $key . '%')
                    ->whereStatus(1); // published;
            })->where('created_at', '>', Carbon::now()->subDays($range)->toDateTimeString());

        } else {
            return $query->orWhere('title', 'LIKE' , '%' . $key . '%')
                ->orWhere('content', 'LIKE' , '%' . $key . '%')
                ->whereStatus(1); // published;
        }

    }


    /**
     * Query to get all published question
     *
     * @param $query
     * @return mixed
     */
    public function scopePublished($query) {
        return $query->whereStatus(1);
    }


    /**
     * The question detail may store in rich html tag.
     * we change it to summary block
     */
    public function getSummaryAttribute() {
        $html = new Htmldom;
        $html->load($this->content);

        // delete code
        foreach ($html->find('pre') as $pre) {
            $pre->outertext = '**Code**';
        }
        $html->load($html->save());

        // delete link
        foreach ($html->find('a') as $pre) {
            $pre->outertext = '**Link**';
        }
        $html->load($html->save());

        $output = $html->plaintext;


        $output_image = "";
        // for <img> tag
        if (count($html->find('img')) > 0) {
            $image_html = $html->find('img', 0);
            $image = Image::isFromThisSite($image_html->src);
            if ($image) {
                $image_html->src = DImage($image->id, 200, 112);
                $image_html->height = null;
                $image_html->width = null;
                $output_image = $output_image . $image_html->outertext;
            }
        }

        return $output_image . truncateText($output, 450);
    }

    /**
     * To full json format
     *
     * @return array
     */
    public function toJsonFull() {
        $topics = [];
        foreach ($this->topics as $topic) {
            array_push($topics, $topic->json);
        }
        return [
            'id' => $this->id,
            'title' => $this->title,
            'content' => $this->content,
            'topics' => $topics,
            'reward' => $this->reward,
            'summary' => false,
        ];
    }

    /**
     * To json summay format
     */
    public function toJsonSummary() {
        $topics = [];
        foreach ($this->topics as $topic) {
            array_push($topics, $topic->json);
        }
        return [
            'id' => $this->id,
            'title' => $this->title,
            'content' => $this->summary,
            'topics' => $topics,
            'reward' => $this->reward,
            'summary' => true,
        ];
    }
}
