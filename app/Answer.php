<?php

namespace App;

use Carbon\Carbon;
use Illuminate\Database\Eloquent\Model;
use Htmldom;
use Auth;
use App\Image;

class Answer extends Model
{
    /**
     * Define fillable field in the model
     *
     * @var array
     */
    protected $fillable = [
        'answer',
        'status'
    ];

    /**
     * Override create method for creating necessary associate model
     *
     * @param array $attributes
     * @return static
     */
    public static function create(array $attributes = []) {
        $answer = parent::create($attributes); // TODO: Change the autogenerated stub
        // answer hit
        Hit::create([
            'owner_type' => 'App\Answer',
            'owner_id' => $answer->id
        ]);
        return $answer;
    }

    /**
     * Override update function so that it could record answer content history
     *
     * @param array $attributes
     * @param array $options
     * @return bool|int
     */
    public function update(array $attributes = [], array $options = [])
    {
        $user = Auth::user();

        if (isset($options['history']) && $options['history']) {
            // set answer history
            if (isset($attributes['answer']) && $attributes['answer'] != $this->answer) {
                $history = History::create([
                    'user_id' => $user->id,
                    'type' => 1,
                    'text' => $this->answer
                ]);
                $this->histories()->save($history);
            }
        }

        return parent::update($attributes, $options); // TODO: Change the autogenerated stub
    }

    /**
     * Close an answer
     *
     * @return bool
     */
    public function close() {
        $user = Auth::user();
        // check authority
        if (!$user->operation(15)) {
            return false;
        }

        // change question status
        $this->status = 3;
        $this->save();

        return true;
    }

    /**
     * open an answer
     *
     * @return bool
     */
    public function open() {
        $user = Auth::user();
        // check authority
        if (!$user->operation(15)) {
            return false;
        }

        // change question status
        $this->status = 1;
        $this->save();

        return true;
    }

    /**
     * Determine if the answer is closed
     *
     * @return bool
     */
    public function isClosed() {
        return $this->status == 3;
    }

    /**
     * Return the latest close reason for the answer
     */
    public function closeReason() {
        if ($this->histories()->whereType(2)->exists()) {
            return $this->histories()
                ->whereType(2)->orderBy('created_at', 'desc')
                ->first()->text;
        } else {
            return false;
        }
    }

    /**
     * A Answer belong to a question
     *
     * @return \Illuminate\Database\Eloquent\Relations\BelongsTo
     */
    public function question() {
        return $this->belongsTo('App\Question', 'question_id');
    }

    

    /**
     * A answer belongs to a user (question answered by a user)
     *
     * @return \Illuminate\Database\Eloquent\Relations\belongsTo
     */
    public function owner() {
        return $this->belongsTo('App\User', 'user_id');
    }

    /**
     * A answer can be voted up by many users
     *
     * @return \Illuminate\Database\Eloquent\Relations\belongsToMany
     */
    public function vote_up_users() {
        return $this->belongsToMany('App\User', 'user_vote_up_answer')->withTimestamps();
    }

    /**
     * A answers can be voted down by many users
     *
     * @return \Illuminate\Database\Eloquent\Relations\belongsToMany
     */
    public function vote_down_users() {
        return $this->belongsToMany('App\User', 'user_vote_down_answer')->withTimestamps();
    }

    /**
     * A answer may have replies
     *
     * @return \Illuminate\Database\Eloquent\Relations\MorphMany
     */
    public function replies() {
        return $this->morphMany('App\Reply', 'for_item');
    }

    /**
     * A answer may belongs to many bookmarks
     *
     * @return \Illuminate\Database\Eloquent\Relations\BelongsToMany
     */
    public function bookmarks() {
        return $this->belongsToMany('App\Bookmark', 'bookmark_answer')->withTimestamps();
    }

    /**
     * A answer may have histories
     *
     * @return \Illuminate\Database\Eloquent\Relations\MorphMany
     */
    public function histories() {
        return $this->morphMany('App\History', 'for_item');
    }

    /**
     * A answer has a hit object
     */
    public function getHitAttribute() {
       return Hit::whereOwnerType('App\Answer')->whereOwnerId($this->id)->first();
    }

    /**
     * Set answer as publish status
     *
     * @return bool
     */
    public function publish() {
        $user = Auth::user();
        // set an answer as publish status
        // check if answer belongs to the current user
        if ($user->id != $this->owner->id || $this->status != 2) {
            // only draft status answer can be pulished
            return false;
        }

        // change answer status
        $this->status = 1;
        // update time
        $this->created_at = Carbon::now();
        $this->save();

        return true;
    }

    /**
     * Get published answer
     *
     * @param $query
     * @return mixed
     */
    public function scopePublished($query) {
        return $query->whereStatus(1);
    }

    /**
     * Save draft to answer
     *
     * @param array $attributes
     * @param array $options
     * @return bool
     */
    public function saveDraft(array $attributes = [], array $options = []) {
        $user = Auth::user();
        // already saved answer
        if ($this->owner->id != $user->id || $this->status != 2) {
            // this answer is not created by the user
            // the answer is in published status / close status
            return false;
        }
        // update answer
        $this->update($attributes, $options);
    }

    /**
     * Display human readable created at date
     *
     * @return string
     */
    public function getCreatedAtHumanReadableAttribute() {
        $created_at = Carbon::parse($this->created_at);
        // if the created at date is more than 3 month ago, display the date
        if (Carbon::now()->subMonth(3)->gte($created_at)) {
            return $created_at->format('Y-m-d');
        } else {
            // or display the humanReadble text (e.g 2 days ago)
            return $created_at->diffForHumans();
        }

    }

    /**
     * Display the net votes of the current answer
     *
     * @return mixed
     */
    public function getNetVotesAttribute() {
        return $this->vote_up_users()->count() - $this->vote_down_users()->count();
    }


    /**
     * Search for answers
     *
     * @param $query
     * @param $key
     * @param null $range
     * @return mixed
     */
    public function scopeNoneSimilarMatch($query, $key, $range = null) {
        if ($range != null) {
            return $query->where('created_at', '>', Carbon::now()->subDays($range)->toDateTimeString())
                ->where('answer', 'LIKE', '%' . $key . '%')
                ->published(); // published

        } else {
            return $query->where('answer', 'LIKE' , '%' . $key . '%')
                ->published(); // published
        }

    }

    /**
     * Count answers(collection) votes
     *
     * @param $answers
     * @return int
     */
    public static function countVotes($answers) {
        $count = 0;
        foreach ($answers as $answer) {
            $count += $answer->netVotes;
        }
        return $count;
    }

    /**
     * The answer may store in rich html tag.
     * we change it to summary block
     */
    public function getSummaryAttribute() {
        $html = new Htmldom;
        $html->load($this->answer);

        // delete code
        foreach ($html->find('pre') as $pre) {
            $pre->outertext = '**Code**';
        }
        $html->load($html->save());

        // delete link
        foreach ($html->find('a') as $pre) {
            $pre->outertext = '**Link**';
        }
        $html->load($html->save());

        $output = $html->plaintext;


        $output_image = "";
        // for <img> tag
        if (count($html->find('img')) > 0) {
            $image_html = $html->find('img', 0);
            $image = Image::isFromThisSite($image_html->src);
            if ($image) {
                $image_html->src = DImage($image->id, 200, 112);
                $image_html->height = null;
                $image_html->width = null;
                $output_image = $output_image . $image_html->outertext;
            }
        }

        return $output_image . truncateText($output, 450);
    }

    /**
     * to json file as answer detail
     *
     * @return array
     */
    public function jsonAnswerDetail() {
        $user = Auth::user();
        $answer_basic = [
            'id' => $this->id,
            'user_name' => $this->owner->name,
            'user_id' => $this->owner->id,
            'user_bio' => $this->owner->bio,
            'user_pic' => DImage($this->owner->settings->profile_pic_id, 25, 25),
            'user_url' => action('PeopleController@show', $this->owner->url_name),
            'answer' => $this->summary,
            'created_at' => $this->createdAtHumanReadable,
            'votes' => $this->netVotes,
            'numComment' => $this->replies->count(),
            'status' => true,
        ];

        // auth user get more
        if ($user) {
            $vote_up_class = $this->vote_up_users->contains($user->id) ? 'active' : '';
            $vote_down_class = $this->vote_down_users->contains($user->id) ? 'active' : '';
            $answer_basic['canVote'] = $this->owner->canAnswerVoteBy($user) && !$this->isClosed();
            $answer_basic['canEdit'] = $this->owner->id == $user->id;
            $answer_basic['vote_up_class'] = $vote_up_class;
            $answer_basic['vote_down_class'] = $vote_down_class;
        } else {
            $answer_basic['guest'] = true;
        }
        return $answer_basic;
    }

    /**
     * To json format for answer display
     *
     * @return array
     */
    public function jsonAnswerSummary() {
        $topics = [];
        foreach ($this->question->topics as $topic) {
            array_push($topics, $topic->json);
        }
        sort($topics);

        $answer_basic = [
            'answer' => [
                'id' => $this->id,
                'owner' => [
                    'name' => $this->owner->name,
                    'bio' => $this->owner->bio,
                    'url_name' => $this->owner->url_name,
                ],
                'answer' => $this->summary,
                'netVotes' => $this->netVotes,
                'numComment' => $this->replies()->count(),
            ],
            'id' => $this->question->id,
            'topics' => $topics,
            'topic_pic' => DImage($this->question->topics->first()->avatar_img_id, 40, 40),
            'title' => $this->question->title,
        ];

        $user = Auth::user();
        if ($user) {
            $vote_up_class = $this->vote_up_users->contains($user->id) ? 'active' : '';
            $vote_down_class = $this->vote_down_users->contains($user->id) ? 'active' : '';
            $answer_basic['answer']['vote_up_class'] = $vote_up_class;
            $answer_basic['answer']['vote_down_class'] = $vote_down_class;
            $answer_basic['answer']['canVote'] = $this->owner->canAnswerVoteBy($user);
            $answer_basic['answer']['canEdit'] = $this->owner->id == $user->id;
            $answer_basic['subscribed'] = $user->subscribe->checkHasSubscribed($this->question->id, 'question');
        } else {
            $answer_basic['guest'] = true;
        }

        return $answer_basic;
    }
}
